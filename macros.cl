(defvar *actual-cont* #'identity)
(define-symbol-macro *cont* *actual-cont*)
(defmacro =defun (name parameters &body body)
  (let ((f (intern (concatenate 'string
                                "="
                                (symbol-name name)))))
    `(progn
       (defmacro ,name ,parameters
         `(,',f *cont* ,,@parameters))
       (defun ,f (*cont* ,@parameters)
         ,@body))))
(defmacro =bind (parameters expression &body body)
  `(let ((*cont* #'(lambda ,parameters ,@body)))
     ,expression))
(defmacro =values (&rest return-values)
  `(funcall *cont* ,@return-values))
(defmacro =funcall (fn &rest arguments)
  `(funcall ,fn *cont* ,@arguments))
(defmacro =apply (fn &rest arguments)
  `(apply ,fn *cont* ,@arguments))
(defmacro =lambda (parameters &body body)
  `#'(lambda (*cont* ,@parameters)
       ,@body))
(defmacro =if (condition then &optional else)
    `(if ,condition
         (let ((*cont* #'(lambda () ,then)))
             ,else)
         (let ((*cont* #'(lambda () ,else)))
         ,then)))
(defmacro =while (condition &body body)
    `(let ((*cont* #'(lambda () ,@body)))
         (while ,condition
         ,@body)))
(defmacro =for (var from to &body body)
    `(let ((*cont* #'(lambda () ,@body)))
         (let ((,var ,from))
             (while (< ,var ,to)
             (let ((*cont* #'(lambda () ,@body)))
                 ,@body)
             (setq ,var (1+ ,var))))))
(defmacro =for-each (var list &body body)
    `(let ((*cont* #'(lambda () ,@body)))
         (let ((,var (car ,list)))
             (while ,var
             (let ((*cont* #'(lambda () ,@body)))
                 ,@body)
             (setq ,list (cdr ,list))
             (setq ,var (car ,list))))))
(defmacro =return (&rest values)
    `(funcall *cont* ,@values))
(defmacro =throw (tag &rest values)
    `(funcall *cont* ,@values))
(defmacro =try (&rest body)
    `(let ((*cont* #'(lambda () ,@body)))
         (condition-case tag
             (progn ,@body)
             (t (funcall *cont* tag)))))
(defmacro =catch (tag &rest body)
    `(let ((*cont* #'(lambda () ,@body)))
         (condition-case tag
             (progn ,@body)
             (t (funcall *cont* tag)))))
(defmacro =finally (&rest body)
    `(let ((*cont* #'(lambda () ,@body)))
         (condition-case tag
             (progn ,@body)
             (t (funcall *cont* tag)))))
(defmacro =yield (&rest values)
    `(funcall *cont* ,@values))
(defmacro =yield-from (expression)
    `(funcall *cont* ,expression))
(defmacro =yield-to (expression &rest body)
    `(funcall *cont* ,expression ,@body))
(defmacro =await (expression &optional timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-for (expression timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-until (expression &optional timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-when (expression &optional timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-while (expression &optional timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-until-for (expression timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-when-for (expression timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-while-for (expression timeout)
    `(funcall *cont* ,expression ,timeout))
(defmacro =await-for-each (list &optional timeout)
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-for (list timeout)
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-when (list timeout)
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-until (list timeout)
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-when-for (list timeout)
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-until-for (list timeout)  
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-while (list timeout)
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-while-for (list timeout)  
    `(funcall *cont* ,list ,timeout))
(defmacro =await-for-each-until-for (list timeout)  
    `(funcall *cont* ,list ,timeout))
